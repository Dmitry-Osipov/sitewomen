# Конспект по созданию сайта с использованием фреймворка Django.
## **I. Установка Django и создание проекта.**
### **1. Создание нового проекта.**
1) Открываем консоль, проверяем работоспособность интерпретатора Python командой:
```bash
python3 --version или python3 -V
```
2) Далее переходим в нужную папку, где у нас будет храниться проект, создаём там виртуальное окружение командой:
```bash
python3 -m venv <название_виртуального_окружения>
```
3) Далее запускаем виртуальное окружение командой:
```bash
source <папка_проекта>/bin/activate
```
В результате должна появиться надпись (venv - или название нашего виртуального окружения, если название отлично от стандартного), означающая, что мы находимся в виртуальном окружении с именем djvenv. Если теперь выполнить команду:
```bash
pip3 list
```
то увидим всего два пакета: сам pip и setuptools. То есть, это чистое виртуальное окружение, в котором два пакета и интерпретатор языка Python.

Сразу отмечу, чтобы выйти из виртуального окружения достаточно выполнить команду:
```bash
deactivate
```
и мы возвращаемся в глобальное окружение.
4) Все дальнейшие действия будут проходить в PyCharm. Открываем папку нашего проекта. Указываем интерпретатор из установленного окружения. 
5) Далее, находясь в корневой папке проекта, мы должны выполнить непосредственно установку Django с помощью очевидной команды:
```bash
pip3 install django==4.2.1
```
Следом мы можем проверить установку Django, выполнив команду:
```bash
pip3 list
```
Мы ожидаем увидеть указанную версию Django и несколько пакетов, необходимых для его работы. 
6) Но это лишь ядро фреймворка с общим функционалом. Используя это ядро, мы можем создавать множество разных сайтов под управлением Django в рамках текущего виртуального окружения. Чтобы посмотреть список команд ядра, достаточно в терминале записать:
```bash
django-admin
```
7) Для создания сайта потребуется команда startproject, которая записывается так:
```bash
django-admin startproject <имя_проекта>
```
Здесь имя проекта обычно является доменным именем.
8) В итоге фреймворк создал папку с именем проекта (у меня sitewomen) в рабочей папке проекта. Внутри этой папки имеется одноимённая вложенная папка пакета, который определяет конфигурацию сайта. Поэтому его часто так и называют - пакетом конфигурации. Также есть ещё один отдельный файл manage.py, через который и производится управление данным сайтом. Например, мы будем создавать приложение, выполнять миграции БД, запускать тестовый веб-сервер и так далее. В действительности это всего лишь своеобразная утилита, посредник, который передаёт наши команды django-admin и выполняет их "от лица" нашего сайта.
9) Запустим тестовый веб-сервер и убедимся, что созданный сайт работает. Переходим в папку sitewomen:
```bash
cd sitewomen
```
и выполним файл manage.py с командой runserver:
```bash
python3 manage.py runserver
```
Чтобы остановить работу сервера, требуется нажать комбинацию клавиш control+C.

Также запуск сервера можно менять под нужные параметры:
```bash
python3 manage.py runserver <порт>
```
или
```bash
python3 manage.py runserver <IP_адресс>:<порт>
```
### **2. Модель MTV. Добавление первого приложения.**
#### **Модель MTV.**
Вначале, когда запрос приходит на фреймворк, он пропускается через блок маршрутизации:

![Модель MTV](images/MTV.jpeg)

Здесь фиксируется тип URL-адреса и в списке шаблонов предопределённых адресов ищется первое совпадение. Например, пользователь вводит запрос:
```http request
http://127.0.0.1:8000/
```
Это есть не что иное, как главная страница сайта, фактически пустой запрос без параметров.

Следующий запрос:
```http request
http://127.0.0.1:8000/category/1/
```
Соответствует шаблону:
```http request
category/<число>
```
Это уже другой маршрут. 

Или такой запрос:
```http request
http://127.0.0.1:8000/women/madonna/
```
с шаблоном:
```http request
women/<слаг (строчка)>
```
И так далее. У нас может быть прописано множество типов URL-адресов и каждый шаблон связан со своим обработчиком - представлением (иногда его ещё называют контроллером). Если текущий запрос от пользователя не совпал ни с одним предопределённым URL, то возвращается код ошибки 404 - страница не найдена. 

Предположим, что маршрутизатор нашёл совпадение. Далее активизируется представление, связанное с найденным типом URL-адреса. Представление - это функция или класс, который отвечает за формирование ответа на соответствующий запрос. Как правило, ответом является HTML-страница. Эта страница затем возвращается клиенту, и он видит её в браузере. Так вот, чтобы представление могло сформировать страницу, в общем случае, требуются данные (информация) плюс шаблоны, в которые эти данные упаковываются. Например, приходит запрос на вывод с страницы о Мадонне:
```http request
http://127.0.0.1:8000/women/madonna/
```
срабатывает соответствующее представление, которое берёт шаблон информационной страницы и наполняет её данными об этой певице, хранящимися в БД:

![Пример работы модели MTV](images/MTV_ex.jpeg)

На выходе получаем сформированную HTML-страницу, которая и возвращается пользователю. Вот такое разделение на данные (model), шаблоны (templates) и представления (views) представляет собой общеизвестный паттерн MTV, то есть, разделение данных и HTML-шаблонов. Техника довольно эффективна и удобна, так как позволяет независимо наполнять БД информацией и параллельно разрабатывать или изменять функционал сайта. Кроме того здесь легче находить ошибки, в отличие от подхода, когда в одном скрипте присутствует и подключение к БД и оперирование шаблонами. Методика «разделяй и властвуй» очень хорошо себя зарекомендовала в мире программирования и довольно часто используется в том или ином виде.
#### **Добавление первого приложения.**
Согласно философии Django мы должны создать новое приложение в рамках нашего сайта. Что это за приложение и зачем оно вообще нужно? Разработчики фреймворка решили, что каждая самостоятельная часть сайта должна представляться в виде своего отдельного приложения. Например, создавая информационный сайт, мы должны будем определить приложение для отображения страниц этого сайта по определенным запросам. Далее, к нам приходит руководитель проекта и сообщает, что еще нужно реализовать форум на сайте. И так как это функционально независимая часть сайта, то мы создаем еще одно приложение для форума. Затем руководитель вспомнил, что еще нужно сделать раздел с опросом пользователей по разным тематикам. И на сайте появляется еще одно приложение – для опроса. И так далее. Каждая логически и функционально независимая часть сайта предполагает его реализацию в виде отдельного приложения:

![Структура сайта по приложениям](images/app_ex.png)

Приложения в Django следует реализовывать максимально независимыми, в идеале – полностью независимыми, чтобы в дальнейшем мы могли их просто скопировать в другой сайт и там оно сразу же начинало бы работать. Это не всегда удается, но к этому нужно стремиться.

Итак, давайте создадим в нашем сайте первое приложение, которое возьмет на себя базовый функционал, то есть, оно и будет являться ядром нашего сайта. 
1) Для этого открыв терминал и находясь в каталоге django/sitewomen, выполним команду:
```bash
python3 manage.py startapp women
```
Здесь startapp – команда для создания нового приложения; women – название приложения. Название может быть любым (мы его придумываем сами), но так, чтобы оно отражало суть своего функционала. В данном случае приложение women (женщины) будет формировать станицы сайта об известных женщинах из разных областей жизни: кино, спорт, музыка, политика.

После выполнения команды у нас в проекте появилась еще одна папка – women, которая уже содержит несколько файлов, в том числе, и файл __init__.py. Следовательно, приложение в Django реализуется как пакет языка Python. Также здесь присутствует одна вложенная папка migrations для хранения миграций БД нашего приложения. Подробнее о ней мы поговорим позже. 

Остальные файлы имеют следующее назначение:
- admin.py – для настройки админ-панели сайта (админ-панель поставляется совместно с Django и каждый сайт может сразу ее использовать);
- apps.py – для настройки (конфигурирования) текущего приложения;
- models.py – для хранения ORM-моделей для представления данных из базы данных;
- tests.py – модуль с тестирующими процедурами;
- views.py – для хранения представлений (контроллеров) текущего приложения.

2) После создания приложения его необходимо зарегистрировать в проекте нашего сайта, чтобы фреймворк Django «знал» о его существовании и корректно с ним работал. Для этого нужно перейти в пакет конфигурации сайта (sitewomen), открыть файл settings.py и в списке INSTALLED_APPS прописать новое приложение. В нем уже прописаны несколько стандартных приложений самого фреймворка и к ним мы просто добавим свое:
```python
# sitewomen/settings.py
INSTALLED_APPS = [
    ...
    'women',
]
```
По идее этого вполне достаточно и все будет работать, но в действительности Django обращаясь к этому пакету находит файл apps.py, откуда и берет настройки приложения из класса WomenConfig. Чтобы в дальнейшем каждый раз не конкретизировать этот путь, следует прописать его сразу в списке приложений:
```python
# sitewomen/settings.py
INSTALLED_APPS = [
    ...
    'women.apps.WomenConfig',
]
```
На этом первое (основное) приложение сайта создано.
### **3. Маршрутизация и функции представления.**
Теперь следует написать функции представления и добавить путь к этим функциям. Начнём с функции представления для стартовой страницы:
```python
# women/views.py
def index(request):
    return HttpResponse('Страница приложения women.')
```
Здесь указывается первый обязательный параметр request - это ссылка на экземпляр класса HttpRequest, который содержит информацию о запросе, сессии, куках и так далее. То есть через переменную request нам доступна вся возможная информация в рамках текущего запроса. На выходе эта функция возвращает экземпляр объекта HttpResponse, который будет автоматически формировать нужный заголовок ответа, а содержимое будет представлено простой строкой. 

Теперь нам требуется связать представления с соответствующим URL-адресом. Для этого в пакете конфигурации **_sitewomen_** откроем файл **_urls.py_** и в список адресов urlpatterns добавим новый путь с помощью специальной функции path:
```python
# sitewomen/urls.py
urlpatterns = [
    path('admin/', admin.site.urls),
    path('women/', index),
]
```
Здесь первый параметр - это суффикс URL-адреса, то есть часть URL-адреса, которая добавляется после доменного имени (при этом в конце принято указывать слэш). Например, если сайт располагается по адресу:
```http request
http://127.0.01:8000
```
то первый аргумента 'women/' добавляется в конце этого пути:
```http request
http://127.0.01:8000/women/
```
Именно такой адрес мы сейчас и определяем. Второй аргумент - это ссылка на функцию представления, которая будет автоматически вызываться при срабатывании указанного URL-адреса и возвращать ответ на клиентский запрос. В нашем примере ответ формируется в виде экземпляра класса HttpResponse.

Далее следует импортировать функцию index, чтобы она была доступна в пакете конфигурации:
```python
# sitewomen/urls.py
from women.views import index
```
Если IDE здесь указывает ошибку, то это потому, что рабочим каталогом следует указать проект sitewomen. 

Проверим работоспособность нового приложения и маршрута. Запустим тестовый веб-сервер:
```bash
python3 manage.py runserver
```
И откроем страницу:
```http request
http://127.0.0.1:8000/women/
```
В рамках этого приложения мы можем определять сколько угодно таких функций, связанных с разными URL-адресами. Например, пропишем ещё одну функцию для отображения списка статей по рубрикам:
```python
# women/views.py
def categories(request):
    return HttpResponse('<h1>Статьи по категориям</h1>')
```
Мы здесь используем тег h1, чтобы браузер отобразил эту строку как заголовок первого уровня. Затем добавляем ещё один путь в список urlpatterns:
```python
# sitewomen/urls.py
urlpatterns = [
    path('admin/', admin.site.urls),
    path('women/', views.index),
    path('cats/', views.categories),
]
```
и делаем импорт всех нудных приложений:
```python
# sitewomen/urls.py
from women import views
```
Теперь имеем новый адрес:
```http request
http://127.0.0.1:8000/cats/
```
по которому отображается заголовок первого уровня. По аналогии мы можем добавлять самые разные URL в наш сайт. 

Однако такой подход, когда маршруты приложения прописываются в пакете конфигурации, нарушает принцип независимости приложений. Для решения данной проблемы Django позволяет вторым аргументом передать вместо функции представления список адресов и связанные с ними функции. Для этого импортируем специальную функцию include:
```python
# sitewomen/urls.py
from django.urls import path, include
```
А затем в списке маршрутов с её помощью подключим список URL уже из нашего приложения women:
```python
# sitewomen/urls.py
urlpatterns = [
    path('admin/', admin.site.urls),
    path('women/', include('women.urls')),
]
```
Мы здесь в качестве параметра указываем строку, в которой сначала записываем имя приложения и через точку файл urls, где будут прописаны маршруты приложения women. Далее всё просто: добавляем в приложение **_women_** новый файл **_urls.py_** и в нём формируем новый список urlpatterns:
```python
# women/urls.py
from django.urls import path
from . import views
 
urlpatterns = [
    path('', views.index),
]
```
Здесь мы. во-первых, импортируем функцию path, которая и связывает URL с функциями представления, и, во-вторых, импортируем модуль views текущего пакета. Далее в списке urlpatterns вызываем функцию path, первым аргументом указываем пустую строку, а вторым аргументом функцию index. Т.к. в основном пакете конфигурации у нас указано, что к адресам 'women.urls' следует добавлять суффикс women/, то функция представления index будет соответствовать адресу:
```http request
http://127.0.0.1:8000/women/
```
Если же добавить адрес cats/:
```python
# women/urls.py
from django.urls import path
from . import views
 
urlpatterns = [
    path('', views.index),
    path('cats/', views.categories),
]
```
То функция представления categories будет соответствовать адресу:
```http request
http://127.0.0.1:8000/women/cats/
```
Таким образом, достаточно просто мы получили относительную независимость нашего приложения women от основного проекта сайта.