# Конспект по созданию сайта с использованием фреймворка Django.
## [Документация.](https://www.djangoproject.com/)
## **I. Установка Django и создание проекта.**
### **1. Создание нового проекта.**
1) Открываем консоль, проверяем работоспособность интерпретатора Python командой:
```bash
python3 --version или python3 -V
```
2) Далее переходим в нужную папку, где у нас будет храниться проект, создаём там виртуальное окружение командой:
```bash
python3 -m venv <название_виртуального_окружения>
```
3) Далее запускаем виртуальное окружение командой:
```bash
source <папка_проекта>/bin/activate
```
В результате должна появиться надпись (venv - или название нашего виртуального окружения, если название отлично от стандартного), означающая, что мы находимся в виртуальном окружении с именем djvenv. Если теперь выполнить команду:
```bash
pip3 list
```
то увидим всего два пакета: сам pip и setuptools. То есть, это чистое виртуальное окружение, в котором два пакета и интерпретатор языка Python.

Сразу отмечу, чтобы выйти из виртуального окружения достаточно выполнить команду:
```bash
deactivate
```
и мы возвращаемся в глобальное окружение.
4) Все дальнейшие действия будут проходить в PyCharm. Открываем папку нашего проекта. Указываем интерпретатор из установленного окружения. 
5) Далее, находясь в корневой папке проекта, мы должны выполнить непосредственно установку Django с помощью очевидной команды:
```bash
pip3 install django==4.2.1
```
Следом мы можем проверить установку Django, выполнив команду:
```bash
pip3 list
```
Мы ожидаем увидеть указанную версию Django и несколько пакетов, необходимых для его работы. 
6) Но это лишь ядро фреймворка с общим функционалом. Используя это ядро, мы можем создавать множество разных сайтов под управлением Django в рамках текущего виртуального окружения. Чтобы посмотреть список команд ядра, достаточно в терминале записать:
```bash
django-admin
```
7) Для создания сайта потребуется команда startproject, которая записывается так:
```bash
django-admin startproject <имя_проекта>
```
Здесь имя проекта обычно является доменным именем.
8) В итоге фреймворк создал папку с именем проекта (у меня sitewomen) в рабочей папке проекта. Внутри этой папки имеется одноимённая вложенная папка пакета, который определяет конфигурацию сайта. Поэтому его часто так и называют - пакетом конфигурации. Также есть ещё один отдельный файл manage.py, через который и производится управление данным сайтом. Например, мы будем создавать приложение, выполнять миграции БД, запускать тестовый веб-сервер и так далее. В действительности это всего лишь своеобразная утилита, посредник, который передаёт наши команды django-admin и выполняет их "от лица" нашего сайта.
9) Запустим тестовый веб-сервер и убедимся, что созданный сайт работает. Переходим в папку sitewomen:
```bash
cd sitewomen
```
и выполним файл manage.py с командой runserver:
```bash
python3 manage.py runserver
```
Чтобы остановить работу сервера, требуется нажать комбинацию клавиш control+C.

Также запуск сервера можно менять под нужные параметры:
```bash
python3 manage.py runserver <порт>
```
или
```bash
python3 manage.py runserver <IP_адресс>:<порт>
```
### **2. Модель MTV. Добавление первого приложения.**
#### **Модель MTV.**
Вначале, когда запрос приходит на фреймворк, он пропускается через блок маршрутизации:

![Модель MTV](images/MTV.jpeg)

Здесь фиксируется тип URL-адреса и в списке шаблонов предопределённых адресов ищется первое совпадение. Например, пользователь вводит запрос:
```http request
http://127.0.0.1:8000/
```
Это есть не что иное, как главная страница сайта, фактически пустой запрос без параметров.

Следующий запрос:
```http request
http://127.0.0.1:8000/category/1/
```
Соответствует шаблону:
```http request
category/<число>
```
Это уже другой маршрут. 

Или такой запрос:
```http request
http://127.0.0.1:8000/women/madonna/
```
с шаблоном:
```http request
women/<слаг (строчка)>
```
И так далее. У нас может быть прописано множество типов URL-адресов и каждый шаблон связан со своим обработчиком - представлением (иногда его ещё называют контроллером). Если текущий запрос от пользователя не совпал ни с одним предопределённым URL, то возвращается код ошибки 404 - страница не найдена. 

Предположим, что маршрутизатор нашёл совпадение. Далее активизируется представление, связанное с найденным типом URL-адреса. Представление - это функция или класс, который отвечает за формирование ответа на соответствующий запрос. Как правило, ответом является HTML-страница. Эта страница затем возвращается клиенту, и он видит её в браузере. Так вот, чтобы представление могло сформировать страницу, в общем случае, требуются данные (информация) плюс шаблоны, в которые эти данные упаковываются. Например, приходит запрос на вывод с страницы о Мадонне:
```http request
http://127.0.0.1:8000/women/madonna/
```
срабатывает соответствующее представление, которое берёт шаблон информационной страницы и наполняет её данными об этой певице, хранящимися в БД:

![Пример работы модели MTV](images/MTV_ex.jpeg)

На выходе получаем сформированную HTML-страницу, которая и возвращается пользователю. Вот такое разделение на данные (model), шаблоны (templates) и представления (views) представляет собой общеизвестный паттерн MTV, то есть, разделение данных и HTML-шаблонов. Техника довольно эффективна и удобна, так как позволяет независимо наполнять БД информацией и параллельно разрабатывать или изменять функционал сайта. Кроме того здесь легче находить ошибки, в отличие от подхода, когда в одном скрипте присутствует и подключение к БД и оперирование шаблонами. Методика «разделяй и властвуй» очень хорошо себя зарекомендовала в мире программирования и довольно часто используется в том или ином виде.
#### **Добавление первого приложения.**
Согласно философии Django мы должны создать новое приложение в рамках нашего сайта. Что это за приложение и зачем оно вообще нужно? Разработчики фреймворка решили, что каждая самостоятельная часть сайта должна представляться в виде своего отдельного приложения. Например, создавая информационный сайт, мы должны будем определить приложение для отображения страниц этого сайта по определенным запросам. Далее, к нам приходит руководитель проекта и сообщает, что еще нужно реализовать форум на сайте. И так как это функционально независимая часть сайта, то мы создаем еще одно приложение для форума. Затем руководитель вспомнил, что еще нужно сделать раздел с опросом пользователей по разным тематикам. И на сайте появляется еще одно приложение – для опроса. И так далее. Каждая логически и функционально независимая часть сайта предполагает его реализацию в виде отдельного приложения:

![Структура сайта по приложениям](images/app_ex.png)

Приложения в Django следует реализовывать максимально независимыми, в идеале – полностью независимыми, чтобы в дальнейшем мы могли их просто скопировать в другой сайт и там оно сразу же начинало бы работать. Это не всегда удается, но к этому нужно стремиться.

Итак, давайте создадим в нашем сайте первое приложение, которое возьмет на себя базовый функционал, то есть, оно и будет являться ядром нашего сайта. 
1) Для этого открыв терминал и находясь в каталоге django/sitewomen, выполним команду:
```bash
python3 manage.py startapp women
```
Здесь startapp – команда для создания нового приложения; women – название приложения. Название может быть любым (мы его придумываем сами), но так, чтобы оно отражало суть своего функционала. В данном случае приложение women (женщины) будет формировать станицы сайта об известных женщинах из разных областей жизни: кино, спорт, музыка, политика.

После выполнения команды у нас в проекте появилась еще одна папка – women, которая уже содержит несколько файлов, в том числе, и файл __init__.py. Следовательно, приложение в Django реализуется как пакет языка Python. Также здесь присутствует одна вложенная папка migrations для хранения миграций БД нашего приложения. Подробнее о ней мы поговорим позже. 

Остальные файлы имеют следующее назначение:
- admin.py – для настройки админ-панели сайта (админ-панель поставляется совместно с Django и каждый сайт может сразу ее использовать);
- apps.py – для настройки (конфигурирования) текущего приложения;
- models.py – для хранения ORM-моделей для представления данных из базы данных;
- tests.py – модуль с тестирующими процедурами;
- views.py – для хранения представлений (контроллеров) текущего приложения.

2) После создания приложения его необходимо зарегистрировать в проекте нашего сайта, чтобы фреймворк Django «знал» о его существовании и корректно с ним работал. Для этого нужно перейти в пакет конфигурации сайта (sitewomen), открыть файл settings.py и в списке INSTALLED_APPS прописать новое приложение. В нем уже прописаны несколько стандартных приложений самого фреймворка и к ним мы просто добавим свое:
```python
# sitewomen/settings.py
INSTALLED_APPS = [
    ...
    'women',
]
```
По идее этого вполне достаточно и все будет работать, но в действительности Django обращаясь к этому пакету находит файл apps.py, откуда и берет настройки приложения из класса WomenConfig. Чтобы в дальнейшем каждый раз не конкретизировать этот путь, следует прописать его сразу в списке приложений:
```python
# sitewomen/settings.py
INSTALLED_APPS = [
    ...
    'women.apps.WomenConfig',
]
```
На этом первое (основное) приложение сайта создано.
### **3. Маршрутизация и функции представления.**
Теперь следует написать функции представления и добавить путь к этим функциям. Начнём с функции представления для стартовой страницы:
```python
# women/views.py
def index(request):
    return HttpResponse('Страница приложения women.')
```
Здесь указывается первый обязательный параметр request - это ссылка на экземпляр класса HttpRequest, который содержит информацию о запросе, сессии, куках и так далее. То есть через переменную request нам доступна вся возможная информация в рамках текущего запроса. На выходе эта функция возвращает экземпляр объекта HttpResponse, который будет автоматически формировать нужный заголовок ответа, а содержимое будет представлено простой строкой. 

Теперь нам требуется связать представления с соответствующим URL-адресом. Для этого в пакете конфигурации **_sitewomen_** откроем файл **_urls.py_** и в список адресов urlpatterns добавим новый путь с помощью специальной функции path:
```python
# sitewomen/urls.py
urlpatterns = [
    path('admin/', admin.site.urls),
    path('women/', index),
]
```
Здесь первый параметр - это суффикс URL-адреса, то есть часть URL-адреса, которая добавляется после доменного имени (при этом в конце принято указывать слэш). Например, если сайт располагается по адресу:
```http request
http://127.0.01:8000
```
то первый аргумента 'women/' добавляется в конце этого пути:
```http request
http://127.0.01:8000/women/
```
Именно такой адрес мы сейчас и определяем. Второй аргумент - это ссылка на функцию представления, которая будет автоматически вызываться при срабатывании указанного URL-адреса и возвращать ответ на клиентский запрос. В нашем примере ответ формируется в виде экземпляра класса HttpResponse.

Далее следует импортировать функцию index, чтобы она была доступна в пакете конфигурации:
```python
# sitewomen/urls.py
from women.views import index
```
Если IDE здесь указывает ошибку, то это потому, что рабочим каталогом следует указать проект sitewomen. 

Проверим работоспособность нового приложения и маршрута. Запустим тестовый веб-сервер:
```bash
python3 manage.py runserver
```
И откроем страницу:
```http request
http://127.0.0.1:8000/women/
```
В рамках этого приложения мы можем определять сколько угодно таких функций, связанных с разными URL-адресами. Например, пропишем ещё одну функцию для отображения списка статей по рубрикам:
```python
# women/views.py
def categories(request):
    return HttpResponse('<h1>Статьи по категориям</h1>')
```
Мы здесь используем тег h1, чтобы браузер отобразил эту строку как заголовок первого уровня. Затем добавляем ещё один путь в список urlpatterns:
```python
# sitewomen/urls.py
urlpatterns = [
    path('admin/', admin.site.urls),
    path('women/', views.index),
    path('cats/', views.categories),
]
```
и делаем импорт всех нудных приложений:
```python
# sitewomen/urls.py
from women import views
```
Теперь имеем новый адрес:
```http request
http://127.0.0.1:8000/cats/
```
по которому отображается заголовок первого уровня. По аналогии мы можем добавлять самые разные URL в наш сайт. 

Однако такой подход, когда маршруты приложения прописываются в пакете конфигурации, нарушает принцип независимости приложений. Для решения данной проблемы Django позволяет вторым аргументом передать вместо функции представления список адресов и связанные с ними функции. Для этого импортируем специальную функцию include:
```python
# sitewomen/urls.py
from django.urls import path, include
```
А затем в списке маршрутов с её помощью подключим список URL уже из нашего приложения women:
```python
# sitewomen/urls.py
urlpatterns = [
    path('admin/', admin.site.urls),
    path('women/', include('women.urls')),
]
```
Мы здесь в качестве параметра указываем строку, в которой сначала записываем имя приложения и через точку файл urls, где будут прописаны маршруты приложения women. Далее всё просто: добавляем в приложение **_women_** новый файл **_urls.py_** и в нём формируем новый список urlpatterns:
```python
# women/urls.py
from django.urls import path
from . import views
 
urlpatterns = [
    path('', views.index),
]
```
Здесь мы. во-первых, импортируем функцию path, которая и связывает URL с функциями представления, и, во-вторых, импортируем модуль views текущего пакета. Далее в списке urlpatterns вызываем функцию path, первым аргументом указываем пустую строку, а вторым аргументом функцию index. Т.к. в основном пакете конфигурации у нас указано, что к адресам 'women.urls' следует добавлять суффикс women/, то функция представления index будет соответствовать адресу:
```http request
http://127.0.0.1:8000/women/
```
Если же добавить адрес cats/:
```python
# women/urls.py
from django.urls import path
from . import views
 
urlpatterns = [
    path('', views.index),
    path('cats/', views.categories),
]
```
То функция представления categories будет соответствовать адресу:
```http request
http://127.0.0.1:8000/women/cats/
```
Таким образом, достаточно просто мы получили относительную независимость нашего приложения women от основного проекта сайта.
### **4. Отладка проекта Django в PyCharm.**
Мы уже умеем создавать простейшее приложение на Django и наблюдать его работу с использованием тестового веб-сервера. Но, прежде чем идти дальше, было бы еще хорошо научиться отлаживать непосредственно и программный код, т.е. запускать программу в режиме отладки. Если в PyCharm мы сделаем это стандартными средствами, поставим точку останова и запустим программу в режиме отладки, то получим ошибку, так как проект Django следует исполнять командой:
```bash
python3 manage.py runserver
```
И эта команда по умолчанию не запускает наши скрипты в debug-режиме. Чтобы это поправить, необходимо создать свой файл конфигурации. Для этого необходимо кликнуть в PyCharm на кнопку «Add Configurations…» или «Edit Configurations…»:

![Кнопка добавления новых конфигураций](images/edit_conf.jpeg)

В появившемся окне нажмите «+», выберите Python и затем, заполните следующие поля:
- name: sitewomen
- Working directory: D:\Python\Projects\django\sitewomen (увидим версию интерпретатора языка Python)
- Script path: D:\Python\Projects\django\sitewomen\manage.py
- Parameters: runserver

![Установка настроек для запуска тестового сервера](images/set_script.jpeg)

После этого запускаем через Debug проект Django и, как видим, имеем возможность останавливаться в выставленных точках отладки.

Обратите внимание, что перед запуском новой конфигурации отладочный веб-сервер должен быть остановлен. Дело в том, что один порт может быть занят только одной программой, поэтому если сервер ранее уже был запущен стандартным способом, то pycharm в режиме отладки не будет останавливаться в точках останова.
### **5. Динамические URL. Пользовательские конвертеры.**
Сейчас в нашем проекте маршруты приложения women подключаются с помощью функции include:
```python
# sitewomen/urls.py
urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('women.urls')),
]
```
Соответственно, за главную страницу отвечает функция представления index, а за вывод разделов - функция categories. Но у нас может быть множество категорий и хотелось бы, например, их отображать с помощью таких URL:
```http request
http://127.0.0.1:8000/cats/1/

http://127.0.0.1:8000/cats/2/

http://127.0.0.1:8000/cats/3/

...
```
Для того, чтобы прописать такой шаблон в Django, в списке адресов приложения следует указать числовой параметр:
```python
# women/urls.py
urlpatterns = [
    path('', views.index),
    path('cats/<int:cat_id>/', views.categories),
]
```
В угловых скобках записан параметр cat_id, который имеет тип int - целочисленный. Этот тип в маршрутах называется конвертером. И указанный путь будет соответствовать любым комбинациям URL с фрагментом "cats/число/". Далее в функции представления categories мы уже можем использовать этот параметр:
```python
# women/views.py
def categories(request, cat_id):
    return HttpResponse(f"<h1>Статьи по категориям</h1><p >id:{cat_id}</p>")
```
Помимо конвертера int в Django можно использовать и другие. Вот список всех [стандартных конвертеров](https://docs.djangoproject.com/en/4.2/topics/http/urls/):
- str – любая не пустая строка, исключая символ ‘/’;
- int – любое положительное целое число, включая 0;
- slug – слаг, то есть, латиница ASCII таблицы, цифры, символы дефиса и подчеркивания;
- uuid – цифры, малые латинские символы ASCII, дефис;
- path – любая не пустая строка, включая символ ‘/’.

Добавим ещё один маршрут для доступа к категориям через слаг:
```python
# women/urls.py
urlpatterns = [
    ...
    path('cats/slug:cat_slug/', views.categories_by_slug),
```
Добавим функцию представления:
```python
# women/views.py
def categories_by_slug(request, cat_slug):
    return HttpResponse(f"<h1>Статьи по категориям</h1><p >slug:{ cat_slug }</p>")
```
И теперь в качестве категории можно указывать не только числа, но и строки в виде слага:
```http request
http://127.0.0.1:8000/cats/3/

http://127.0.0.1:8000/cats/sport/

http://127.0.0.1:8000/cats/music/

http://127.0.0.1:8000/cats/sport-4-me/

...
```
Слаги понятнее для пользователя и поисковых систем. Сайты с такими URL, в среднем, лучше индексируются и занимают более высокие позиции в поисковой выдаче. Причем, когда передается число, то отрабатывает первый маршрут из URL с числовым конвертером, если же числовой шаблон не подходит, то проверяется следующий со слагом. И здесь очень важен порядок. Если поменять и записать сначала конвертер со слагом, а затем, с числом:
```python
# women/urls.py
urlpatterns = [
    path('', views.index),
    path('cats/<slug:cat_slug>/', views.categories_by_slug),
    path('cats/<int:cat_id>/', views.categories),
]
```
то всегда будет отрабатывать слаг, т.к. число - это частный случай слага. На это следует обращать особое внимание: сначала следует прописывать частные конвертеры, а затем более общие.

Если по каким-то причинам представленных типов URL недостаточно, то в Django имеется функция re_path, которая делает всё то же самое, но с использованием регулярных выражений. Например, определим URL, в котором можно указывать год в виде четырёх чисел:
```python
# women/urls.py
urlpatterns = [
    ...
    re_path(r'^archive/(?P<year>[0-9]{4})/', views.archive),
]
```
Здесь year - это имя переменной, которая будет содержать введённый год. 

Добавим функцию представления archive:
```python
# women/views.py
def archive(request, year):
    return HttpResponse(f"<h1>Архив по годам</h1><p >{year}</p>")
```
И теперь мы можем обращаться к этому URL, указывая ровно 4 цифры:
```http request
http://127.0.0.1:8000/arcgive/2020/
```
Если же указать меньше или больше чисел, то шаблон URL не совпадёт и возникнет исключение 404 - страница не найдена.
#### **Создание собственных конвертеров.**
Фреймворк Django позволяет создавать свои собственные конвертеры, используемые при анализе URL-адресов. Например, вместо того, чтобы использовать функцию re_path с регулярным выражением, [мы можем создать конвертер](https://docs.djangoproject.com/en/4.2/topics/http/urls/), который бы выделял и проверял год в URL-адресе.

В частности, в разделе «Registering custom path converters» приведён пример класса FourDigitYearConverter с регулярным выражением для выделения 4 цифр:
```python
# women/converters.py
class FourDigitYearConverter:
    regex = "[0-9]{4}"
 
    def to_python(self, value):
        return int(value)
 
    def to_url(self, value):
        return "%04d" % value
```
В классе есть 2 метода:
- to_python - для преобразования фрагмента URL в требуемый тип данных;
- to_url - для преобразования параметра в формат, требуемый для представлений в URL.

Далее в файле urls.py приложения women зарегистрируем этот конвертер с именем year4 для использования в URL-шаблонах:
```python
# women/urls.py
register_converter(converters.FourDigitYearConverter, "year4")
```
Далее в коллекции urlpatterns этого же файла вместо функции re_path следует прописать:
```python
# women/urls.py
urlpatterns = [
    ...
    path('archive/<year4:year>/', views.archive),
]
```
При этом параметр year будет автоматически преобразован в целое число благодаря методу to_python класса FourDigitYearConverter. В этом легко убедиться, поставив точку останова в функции представления archive и запустив Django в режиме отладки.
### **6. GET- и POST-запросы. Обработчики исключений запросов.**
Структура URL-адреса может содержать дополнительные параметры в GET-запросах. Например, вот так:
```http request
http://127.0.0.1:8000/?name=Gagarina&cat=music

или

http://127.0.0.1:8000/cats/music/?name=Gagarina&type=pop
```
И так далее. Здесь у нас идет специальный стартовый символ – знак вопроса, после которого через амперсанд перечисляются различные параметры в виде пар ключ-значение. Так, через адресную строку можно передавать произвольные данные на сервер в виде таких GET-запросов.

Следующий вопрос, как можно выделять эти значения и обрабатывать их на стороне сервера в функциях представления? Для этого, как раз и существует параметр request – ссылка на объект HttpRequest. Через него мы можем обратиться к специальному словарю:
```python
request.GET
```
где и хранятся все эти данные.

Поправим функцию представления categories_by_slug для отображения словаря GET в консоль:
```python
# women/views.py
def categories_by_slug(request, cat_slug):
    print(request.GET)
    return HttpResponse(f"<h1>Статьи по категориям</h1><p >slug: {cat_slug}</p>")
```
И выполним, например, такой запрос:
```http request
http://127.0.0.1:8000/cats/music/?name=Gagarina&type=pop
```
В консоли увидим значения:
```bash
<QueryDict: {'name': ['Gagarina'], 'type': ['pop']}>
```
Или, можем сначала проверить: есть ли в словаре какие-либо данные и только потом выводить их в консоль:
```python
# women/views.py
def categories_by_slug(request, cat_slug):
    if request.GET:
        print(request.GET)
 
    return HttpResponse(f"<h1>Статьи по категориям</h1><p >slug: {cat_slug}</p>")
```
Помимо GET-запросов в веб-программировании часто используются и POST-запросы. Они, обычно, связаны с передачей данных из форм и позже мы их тоже будем использовать. Здесь же я просто отмечу, что в этом случае вместо коллекции GET используется коллекция POST, а все остальное остается без изменений:
```python
# women/views.py
def categories_by_slug(request, cat_slug):
    if request.POST:
        print(request.POST)
 
    return HttpResponse(f"<h1>Статьи по категориям</h1>slug: {cat_slug}</p>")
```
#### **Обработка исключений при запросах к серверу.**
Следующий важный аспект – это обработка исключений при запросах к серверу. Самым распространенным из них является обращение к несуществующей странице, когда сервер возвращает страницу с кодом 404. Например, если для нашего сайта указать путь:
```http request
http://127.0.0.1:8000/aaa
```
то мы увидим исключение 404 – страница не найдена. Такую информацию мы видим исключительно в процессе отладки нашего сайта, когда глобальная константа DEBUG в пакете конфигурации (файл settings.py) установлена в True.

Давайте посмотрим, что произойдет, если временно перевести ее в значение False. Перейдем в пакет конфигурации, откроем файл settings.py, найдем константу DEBUG и присвоим ей значение False. При запуске тестового сервера у нас возникнет ошибка, что мы должны указать разрешенные хосты. Так как мы сейчас используем хост 127.0.0.1, то его в виде строки и укажем:
```python
# sitewomen/settings.py
DEBUG = False

ALLOWED_HOSTS = ['127.0.0.1']
```
Теперь сервер успешно запустился и при обновлении страницы мы уже видим более дружественную страницу без лишней отладочной информации. Но как нам ее поправить, чтобы отобразить более понятную информацию? Для этого в файле urls.py пакета конфигурации можно переопределить обработчик исключения 404. Для этого ему достаточно присвоить ссылку на функцию, которая и будет формировать ответ для отсутствующих страниц, например, так:
```python
# sitewomen/urls.py
handler404 = page_not_found
```
Мы здесь передаем ссылку на функцию page_not_found, а саму функцию определим в приложении women:
```python
# women/views.py
def page_not_found(request, exception):
    return HttpResponseNotFound('<h1>Страница не найдена</h1>')
```
Обратите внимание, функция принимает два аргумента и возвращает ответ в виде экземпляра класса HttpResponseNotFound, которому передается HTML-страница, отображаемая при неверных запросах. Если теперь мы обновим страницу, то увидим заголовок «Страница не найдена».

В дальнейшем мы увидим, как вместо строки можно возвращать шаблон страницы 404. Сейчас главное понять принцип работы механизма обработки исключений.

Итак, мы предполагаем, что функция page_not_found будет вызываться всякий раз при возникновении исключения 404. И это важный момент. Смотрите, если в какой-либо другой функции представления сгенерировать это исключение, то будет автоматическое перенаправление на функцию page_not_found и пользователь увидит все ту же страницу 404. Например, в функции archive мы сделаем проверку:
```python
# women/views.py
def archive(request, year):
    if year > 2023:
        raise Http404()
 
    return HttpResponse(f"<h1>Архив по годам</h1><p >{year}</p>")
```
Если год больше 2023-го, то генерируется исключение 404 как экземпляр класса Http404 и выполняется перенаправление на функцию page_not_found. Это нам позволяет описывать логику отображения неверных запросов в одном месте программы – в функции page_not_found.

Аналогичным образом можно переопределять [обработчики других исключений](https://docs.djangoproject.com/en/4.2/ref/urls/), например:
- handler500 – ошибка сервера;
- handler403 – доступ запрещен;
- handler400 – невозможно обработать запрос.

Но все они работают в боевом режиме при DEBUG = False. При отладке мы увидим расширенную служебную информацию, помогающую исправлять ошибки при разработке сайта.
### **7. Перенаправления (redirect). Функция reverse.**
Мы продолжаем тему маршрутизации. Очень часто при развитии сайта некоторые его страницы переносятся на другой URL-адрес. И чтобы не потерять позиции этих страниц в поисковой выдаче, поисковым системам нужно явно указать, что страница перемещена либо временно, либо постоянно на новый URL. Это делается с помощью перенаправлений с кодами:
- 301 – страница перемещена на другой постоянный URL-адрес;
- 302 – страница перемещена временно на другой URL-адрес.

#### **Функция redirect.**
В Django подобные редиректы достаточно просто выполняются с помощью функции:
```python
django.shortcuts.redirect
```
Давайте для примера сделаем перенаправление со страницы архива, если год больше 2023:
```python
# women/views.py
def archive(request, year):
    if year > 2023:
        return redirect('/')
 
    return HttpResponse(f"<h1>Архив по годам</h1><p >{year}</p>")
```
Здесь в качестве первого параметра указывается страница, на которую происходит перенаправление, в данном случае – это главная страница сайта. Также в файле settings.py вернем прежнее значение параметра DEBUG:
```python
# sitewomen/settings.py
DEBUG = True
```
Если теперь выполнить запрос:
```http request
http://127.0.0.1:8000/archive/2024/
```
то мы попадем на главную страницу с кодом перенаправления 302 (см. консоль). Если же нам нужно указать постоянный редирект с кодом 301, то записывается дополнительный параметр:
```python
# women/views.py
def archive(request, year):
    ...
    return redirect('/', permanent=True)
    ...
```
Вообще в качестве первого аргумента функции redirect() можно передавать не только конкретный URL, но и представление. В частности, вместо '/' можно передать ссылку на функцию index следующим образом:
```python
# women/views.py
def archive(request, year):
    ...
    return redirect(index, permanent=True)
    ...
```
#### **Классы HttpResponseRedirect и HttpResponsePermanentRedirect.**
Фреймворк Django дополнительно поддерживает классы для выполнения перенаправлений. В частности имеются два класса:
- HttpResponseRedirect – для редиректа с кодом 302;
- HttpResponsePermanentRedirect – для редиректа с кодом 301.

которые можно использовать вместо функции redirect() следующим образом:
```python
# women/views.py
def archive(request, year):
    if year > 2023:
        return HttpResponseRedirect('/')
 
    return HttpResponse(f"<h1>Архив по годам</h1><p >{year}</p>")
```
На самом деле функция redirect() использует в своей работе эти классы, но, вместе с тем, она несколько более гибкая. Поэтому какой вариант выбирать решает сам программист, исходя из логики построения кода.
#### **Параметр name функции path.**
Однако указывать в функции redirect, да и вообще где бы то ни было в приложении конкретный URL-адрес (кроме их списка в коллекции urlpatterns) – это порочная практика, или, как еще говорят – хардкодинг. Вместо этого каждому шаблону пути можно присвоить свое уникальное имя и использовать его в рамках всего проекта.

Давайте определим имена для наших URL-запросов. Для этого перейдем в файл women/urls.py и в каждой функции path пропишем параметр name с уникальными именами:
```python
# women/urls.py
urlpatterns = [
    path('', index, name='home'),
    path('cats/<int:cat_id>/', categories, name='cats_id'), 
    path('cats/<slug:cat_slug>/', categories_by_slug, name='cats'),
    path('archive/<year4:year>/', archive, name='archive'),
]
```
Конечно, эти имена вы можете выбрать и другие – это лишь пример. И далее, в функции redirect мы можем выполнить перенаправление на главную страницу, указав имя home:
```python
# women/views.py
def archive(request, year):
    ...
    return redirect('home', permanent=True)
    ...
```
Как видите, это гораздо понятнее и безопаснее использования конкретных URL-адресов. Если в дальнейшем маршрут изменится, то автоматически изменится и адрес перенаправления для home.
#### **Функция reverse.**
Если же маршрут помимо имени содержит еще параметры, как например, маршрут ‘cats’ с параметром slug, то для корректного перенаправления необходимо в функции redirect() вторым и последующими аргументами передать требуемые параметры. В нашем случае это можно сделать так:
```python
# women/views.py
def archive(request, year):
    ...
    return redirect('cats', 'music')
    ...
```
В результате, функция redirect() вычислит следующий URL:
```http request
http://127.0.0.1:8000/cats/music/
```
и сделает на него перенаправление.

Но мы можем разделить операции вычисления URL и непосредственно перенаправление. Для этого в Django имеется функция:
```python
django.urls.reverse
```
которая возвращает строку URL-адреса, вычисленный на основе переданного имени и набора аргументов. Например, для вычисления адреса маршрута cats с параметром ‘music’ функцию reverse() можно вызвать следующим образом:
```python
# women/views.py
def archive(request, year):
    ...
    url_redirect = reverse('cats', args=('music', ))
    return redirect(url_redirect)  # Или можно вернуть соответствующим классом: HttpResponsePermanentRedirect(url_redirect)
    ...
```
### **8. Шаблоны, начало. Функции render() и render_to_string().**
Если мы откроем наш проект и запустим тестовый веб-сервер, то на главной странице увидим отображение одной короткой строчки. Как вы понимаете, полноценная HTML-страница содержит гораздо больше информации, в том числе, заголовок и подключаемые статические файлы. Конечно, если решать эту задачу «в лоб», то можно было бы написать в функции представления что-то вроде:
```python
# women/views.py
def index(request):
    return HttpResponse('''<!DOCTYPE html>
<html>
<head>
         <title></title>
</head>
<body>
 
</body>
</html>''')
```
Но во что тогда превратится программа! Ее будет сложно читать, исправлять и, кроме того, изменение HTML-страницы повлечет изменение и самого приложения. Это полное безумие! Поэтому неудивительно, что все это выносится за пределы приложения и организуется в виде шаблонов HTML-страниц.

Итак, предположим, что в качестве главной страницы мы бы хотели отобразить некоторый шаблон с именем index.html. Для этого, вначале нам нужно импортировать функции, через которые запускается встроенный в Django шаблонизатор. В самом простом варианте можно использовать функцию:
```python
from django.template.loader import render_to_string
```
которая загружает шаблон из файла, обрабатывает его и выдает результат в виде строки. Например, это можно сделать так:
```python
# women/views.py
def index(request):
    t = render_to_string('путь к шаблону index.html')
    return HttpResponse(t)
```
И здесь мы подошли ко второму важному вопросу: где должны располагаться шаблоны текущего приложения Women? По умолчанию, Django ищет шаблоны в подкаталоге templates нашего приложения. Создадим его. По идее, мы можем располагать здесь наши файлы шаблонов и все должно работать. Но есть один важный нюанс. В каком-либо другом приложении также может оказаться файл с именем index.html. Тогда фреймворк Django будет использовать тот, что встретится первым. Чтобы этого не происходило, в templates приложения принято создавать еще один подкаталог с именем приложения. В нашем случае – women. И уже в него помещать файлы шаблонов. Тогда все наши файлы шаблонов будут отделяться от других дополнительным подкаталогом и это позволит избежать коллизий имен файлов.

Итак, создадим в подкаталоге templates/women файл index.html с содержимым:
```html
<!-- index.html -->
<!DOCTYPE html>
<head>
    <meta charset="UTF-8">
    <title>Главная страница</title>
</head>
<body>
<h1>Главная страница</h1>
</body>
</html>
```
Это будет наш первый простейший шаблон, представляющий главную страницу сайта. И, далее, в функции render укажем путь к этому шаблону:
```python
# women/views.py
def index(request):
    t = render_to_string('women/index.html')
    return HttpResponse(t)
```
Все, при обновлении главной страницы в браузере, мы увидим этот шаблон. Как видите все достаточно просто и удобно. Но можно сделать еще лучше и воспользоваться функцией:
```python
from django.shortcuts import render
```
которая объединяет в себе рендер шаблона и формирование ответа сервера. В результате функция представления index() может быть записана так:
```python
# women/views.py
def index(request):
    return render(request, 'women/index.html')
```
Обратите внимание, для корректного отображения кириллицы все шаблоны рекомендуется сохранять в кодировке utf-8. Тем более что сам Python, начиная с версии 3, по умолчанию использует юникод.

Давайте для примера добавим еще одну страницу и один шаблон на наш сайт – страницу «О сайте». Пропишем следующие пути (в women/urls.py):
```python
# women/urls.py
urlpatterns = [
    path('', index, name='home'),
    path('about/', about, name='about'),
    ...
]
```
И функцию about в файле women/views.py:
```python
# women/views.py
def about(request):
    return render(request, 'women/about.html')
```
Добавим шаблон about.html:
```html
<!-- about.html -->
<!DOCTYPE html>
<head>
    <meta charset="UTF-8">
    <title>О сайте</title>
</head>
<body>
<h1>О сайте</h1>
</body>
</html>
```
И при переходе по адресу:
```http request
http://127.0.0.1:8000/about/
```
этот шаблон будет отображён.
#### **Настройки шаблонизатора.**
При работе функций render_to_string() и render() фреймворк Django использует шаблонизатор, указанный в параметре TEMPLATES файла settings.py пакета конфигурации. В частности мы там видим строчку 'BACKEND': 'django.template.backends.django.DjangoTemplates', означающую, что используется встроенный шаблонизатор Django. Кроме того здесь есть параметры DIRS и APP_DIRS. Параметр DIRS позволяет прописывать нестандартные пути к файлам шаблонов, а APP_DIRS со значением True указывает шаблонизатору Django искать шаблоны также и внутри приложений. Причем, шаблоны сначала ищутся по коллекции DIRS, а затем уже в приложениях. В частности, благодаря этому параметру успешно обнаруживаются наши шаблоны index.html и about.html внутри приложения women.

Вот сама коллекция:
```python
# sitewomen/settings.py
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',  # Стандартный шаблонизатор Django.
        'DIRS': [],  # Этот параметр позволяет описывать нестандартные пути к файлам-шаблонам.
        'APP_DIRS': True,  # Параметр говорит о том, что внутри приложения надо искать подкаталоги стандартном каталоге templates.
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
```
Важно заметить: если установить параметр APP_DIRS в значение False, то при запуске проекта и перехода на главную страницу:
```http request
http://127.0.0.1:8000
```
появится ошибка:
```http request
TemplateDoesNotExist at /
```
говорящая, что шаблон не был найден. Возвращая значение параметра APP_DIRS в True ошибка пропадает.

Обратите внимание, чтобы шаблоны нашего приложения успешно обнаруживались фреймворком Django, приложение должно быть прописано в коллекции INSTALLED_APPS. Если мы его оттуда уберем, то снова возникнет прежняя ошибка. Кстати, ради интереса мы можем ее исправить, добавив абсолютный путь в коллекцию DIRS параметра TEMPLATES. Сделать это можно следующим образом:
```python
# sitewomen/settings.py
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [
            BASE_DIR / 'women' / 'templates'
        ],
        'APP_DIRS': True,
    ...
    },
]
```
Мы здесь воспользовались переменной BASE_DIR, которая хранит абсолютный путь к нашему проекту, и добавили подкаталоги women и templates к файлам шаблонов нашего приложения. Теперь, фреймворк Django без проблем найдет нужные файлы и отобразит на главной странице.

Однако для стандартных приложений так делать не стоит. Достаточно зарегистрировать приложение в коллекции INSTALLED_APPS и создать подкаталог templates для размещения файлов шаблонов. Это правильный стандартный подход.
### **9. Передача данных (переменных) в шаблоны.**
Если посмотреть на файлы index.html или about.html, то это просто текст, который загружается и отдается браузеру по соответствующему запросу. Все так, но в этих же файлах можно прописывать конструкции для отображения информации, например, из переменных или БД. Давайте для начала сделаем так, чтобы на каждой странице был свой заголовок, переданный ей через параметр title. Это можно сделать следующим образом. В файлах index.html и about.html укажем переменную title:
```html
<!-- index.html и about.html -->
<!DOCTYPE html>
<html>
<head>
    <title>{{ title }}</title>
</head>
<body>
<h1>{{ title }}</h1>
</body>
</html>
```
А в функциях представлений передать параметр title соответствующему шаблону. Делается это с помощью словарей. В нашем случае необходимо определить словарь с ключом title и значением, которое будет подставляться вместо этого ключа. Например, так:
```python
# women/views.py
def index(request):
    data = {'title': 'Главная страница'}
    return render(request, 'women/index.html', data)
```
При обновлении страницы увидим, что вместо {{title}} в шаблоне было подставлено значение ключа title словаря data. То есть, внутри шаблонов Django можно прописывать двойные фигурные скобки и указывать параметр (ключ), значение которого здесь будет подставлено.

Или, можно использовать более короткую форму:
```python
# women/views.py
def about(request):
    return render(request, 'women/about.html', {'title': 'О сайте'})
```
Тогда при переходе к странице:
```http request
http://127.0.0.1:8000/about/
```
увидим вместо {{title}} строку «О сайте». Вот в этом и есть роль шаблонов: они описывают структуру страницы, а ее наполнение происходит динамически в самой программе.

Конечно, можно выполнять передачу самых разных типов данных: чисел, строк, списков, кортежей, словарей, объектов классов и так далее. Давайте опишем главное меню сайта с помощью списка:
```python
# women/views.py
import ...
menu = ["О сайте", "Добавить статью", "Обратная связь", "Войти"]
...
```
А, затем, в функциях представления, мы можем передать его как параметр:
```python
# women/views.py
def index(request):
    data = {
        'title': 'Главная страница',
        'menu': menu,
    }
    return render(request, 'women/index.html', context=data)
```
Обратите внимание, я здесь передаю словарь data через именованный аргумент context. Это то же самое, что и просто третьим аргументом прописать data. Иногда в программах можно встретить и такую запись.

В самом простом варианте в шаблоне index.html отобразить такой список можно следующим образом:
```html
<!-- index.html -->
<!DOCTYPE html>
<html>
<head>
    <title>{{ title }}</title>
</head>
<body>
<p>{{ menu }}</p>
<h1>{{ title }}</h1>
</body>
</html>
```
Обновляем главную страницу и видим список из строк. Однако если мы попытаемся в шаблоне обратиться к элементу по индексу:
```html
...
<p>{{ menu[0] }}</p>
...
```
то получим ошибку:
```http request
TemplateSyntaxError at /
```
так как шаблонизатор Django не поддерживает такую операцию.

Давайте в шаблоне about.html также пропишем вывод параметра menu:
```html
<!-- about.html -->
...
<p>{{ menu }}</p>
...
```
Если теперь перейти по адресу:
```http request
http://127.0.0.1:8000/about/
```
то этого списка мы не увидим. Дело в том, что в функции представления about() передается только словарь с ключом title. Ключ menu отсутствует. Поэтому шаблонизатор не находит параметр menu и просто его игнорирует. Обратите внимание, именно игнорирует. Никаких ошибок при этом не возникает.

Давайте для примера передадим в шаблон index.html другие распространенные типы данных:
```python
# women/views.py
class MyClass:
    def __init__(self, a, b):
        self.a = a
        self.b = b
 
 
def index(request):
    data = {
        'title': 'Главная страница',
        'menu': menu,
        'float': 28.56,
        'lst': [1, 2, 'abc', True],
        'set': {1, 1, 2, 3, 2, 5},
        'dict': {'key_1': 'value_1', 'key_2': 'value_2'},
        'obj': MyClass(10, 20),
    }
   
 
    return render(request, 'women/index.html', context=data)
```
И выведем их в шаблоне index.html следующим образом:
```html
<!-- index.html -->
<!DOCTYPE html>
<html>
<head>
         <title>{{ title }}</title>
</head>
<body>
<p>{{ menu }}</p>
<p>{{ float }}</p>
<p>{{ lst }}</p>
<p>{{ set }}</p>
<p>{{ dict }}</p>
<p>{{ obj }}</p>
 
<h1>{{ title }}</h1>
</body>
</html>
```
При обновлении главной страницы увидим все переданные данные. Причем, к ключам словаря и к атрибутам класса можно обращаться через точку следующим образом:
```html
<!-- index.html -->
...
<p>{{ dict.key_1 }}</p>
<p>{{ obj.a }}</p>
...
```
Обратите внимание, что здесь используется оператор «точка» в том числе и у словарей. Прописывать квадратные скобки с указанием ключа недопустимо:
```html
<p>{{ dict['key_1'] }}</p>
```
получим ошибку.

Также следует иметь в виду, что каждый отображаемый параметр должен быть записан в отдельных двойных фигурных скобках. Прописывать несколько параметров нельзя. Например, следующая строчка приведет к ошибке:
```html
<p>{{ obj.a obj.b }}</p>
```
Правильно записывать так:
```html
<p>{{ obj.a }} {{ obj.b }}</p>
```
### **10. Стандартные шаблонные фильтры.**
Данные в шаблонах можно преобразовывать, используя так называемые [фильтры](https://docs.djangoproject.com/en/4.2/ref/templates/builtins/).

Это довольно распространенный и полезный инструмент при построении шаблонов. Давайте рассмотрим основные стандартные фильтры и посмотрим на их работу.

Воспользуемся сразу первым фильтром add из документации. Он позволяет прибавлять некоторое целочисленное значение к числовому параметру, например, так (в шаблоне index.html):
```html
<p>{{ float|add:"50" }}</p>
```
В результате вещественное значение float равное 28.56 будет преобразовано в целое число (с отбрасыванием дробной части) с прибавлением значения 50. Итоговое число 78 будет подставлено в шаблон.

То есть, для применения фильтра к тому или иному параметру, прописывается вертикальная черта, затем, имя фильтра и при необходимости, через двоеточие аргумент фильтра. Чаще всего аргумент записывается в кавычках. Это рекомендуемая практика, так как строка позволяет описывать как числа, так и более сложные данные.

Конечно, все фильтры мы рассматривать не будем, я затрону лишь некоторые. Остальные применяются очевидным образом. Конечно же, советую со всеми ними ознакомиться, чтобы не изобретать велосипед при проектировании шаблонов.

Итак, следующий фильтр capfirst преобразует первый символ строки в заглавную букву. Он записывается без аргументов следующим образом:
```html
<h1>{{ title|capfirst }}</h1>
```
Соответственно, строку в title мы запишем с малой буквы. После обновления главной страницы увидим заголовок 1-го уровня с заглавной буквы. Это, как раз результат применения фильтра.

Существуют похожие фильтры, переводящие все буквы в заглавные или, наоборот, в малые. Они следующие:
```html
<h1>{{ title|upper }}</h1>
<h1>{{ title|lower }}</h1>
```
Далее, фильтр cut позволяет удалять указанный строковый фрагмент из переменной в шаблоне. Например:
```html
<h1>{{ title|cut:" " }}</h1>
```
Удаляет все пробелы из строки title. Если требуется убрать разные символы, то фильтр cut можно повторить, записав его еще раз:
```html
<h1>{{ title|cut:" "|cut:"?" }}</h1>
```
Теперь, если из строки title удаляются и пробелы и символы вопросов. Это пример того, как можно по цепочке вызывать фильтры в шаблонах.

Следующий довольно распространенный фильтр default позволяет для ложных выражений подставлять значение по умолчанию. Например:
```html
<title>{{ main_title|default:"Без заголовка" }}</title>
```
Мы увидим строку «Без заголовка», так как параметр main_title отсутствует. То же самое будет, если переданная строка окажется пустой:
```python
data = {
        'title': 'главная страница',
        'main_title': '',
        ...
    }
```
Но, при наличии в ней хотя бы одного символа, увидим значение параметра main_title:
```python
data = {
        'title': 'главная страница',
        'main_title': 'title',
        ...
    }
```
Следующий фильтр divisibleby позволяет проверять на делимость одного числа на другое. Он возвращает значение True или False в зависимости от результата. В частности с его помощью можно выбирать числа кратные 2, 3 и так далее. Довольно полезная операция. Например:
```html
<p>{{ float|divisibleby:"2" }}</p>
```
Выдаст True, так как целое число 28 кратно 2. А вот если вместо 2 прописать 3, то получим значение False.

Следующая пара фильтров first и last позволяют выделять первый и последний элементы списка или кортежа. Например:
```html
<p>{{ menu|first }}</p>
<p>{{ menu|last }}</p>
```
Следующий довольно полезный фильтр join работает по аналогии с известным строковым методом join() следующим образом:
```html
<p>{{ menu|join:" | " }}</p>
```
Увидим в браузере строку:
```http request
О сайте | Добавить статью | Обратная связь | Войти
```
Фильтр length возвращает длину коллекции. Это аналог функции len():
```html
<p>{{ lst|length }}</p>
```
Есть довольно интересный фильтр slugify, который конвертирует строку в так называемый слаг – последовательность символов из малых латинских букв, цифр и дефиса. Слаги часто используют для формирования дружественных URL-адресов и об этом мы еще будем говорить. А здесь приведу лишь пример его использования:
```html
<p>{{ "The Main Page"|slugify }}</p>
```
Это были все самые основные фильтры.
#### **Использование фильтров в программе.**
Все эти фильтры можно использовать не только в шаблонах, но и непосредственно в программе на языке Python. Они расположены в модуле:
```python
django.template.defaultfilters
```
И, например, последним фильтром slugify можно было бы воспользоваться следующим образом:
```python
from django.template.defaultfilters import slugify
```
Затем, в словаре data вызвать эту функцию:
```python
data = {
    'title': 'главная страница',
    'main_title': 'title',
    'url': slugify("The main page"),
    ...
}
```
А в шаблоне index.html вывести параметр url:
```html
<p>{{ url }}</p>
```
Получим тот же самый эффект. То есть, у нас есть самый разный инструментарий и уже сам программист решает, как им воспользоваться, чтобы создать грамотный код разрабатываемого сайта.
### **11. Теги шаблонов. Теги if и for.**
Помимо фильтров, о которых мы говорили на прошлом занятии, в шаблонах фреймворка Django можно прописывать еще и [специальные теги](https://docs.djangoproject.com/en/4.2/ref/templates/builtins/):
```html
{% <название тега> [параметры] %}
```
И чтобы было понятно, что из себя представляют шаблонные теги и для чего они нужны, рассмотрим на этом занятии два очень распространенных тега if и for. Начнем с тега for.

Давайте предположим, что у нас имеется список из данных по известным женщинам, например, такой:
```python
# women/views.py
import ...
data_db = [
    {'id': 1, 'title': 'Анджелина Джоли', 'content': 'Биография Анджелины Джоли', 'is_published': True},
    {'id': 2, 'title': 'Марго Робби', 'content': 'Биография Марго Робби', 'is_published': False},
    {'id': 3, 'title': 'Джулия Робертс', 'content': 'Биография Джулия Робертс', 'is_published': True},
]
...
```
Здесь каждый элемент представляет собой словарь из четырех ключей: id, title, content и is_published. Их назначение вполне очевидно. Последний ключ is_published означает опубликована статья или нет (True – опубликована; False – не опубликована).

В функции представления index сформируем общие данные и передадим их в шаблон index.html:
```python
# women/views.py
def index(request):
    data = {
        'title': 'Главная страница',
        'menu': menu,
        'posts': data_db,
    }
 
    return render(request, 'women/index.html', context=data)
```
Как видите, в шаблоне будет доступна коллекция posts из набора публикуемых статей. Наша задача отобразить этот список. В самом простом варианте это можно сделать следующим образом (в шаблоне index.html):
```html
<!-- index.html -->
<!DOCTYPE html>
<html>
<head>
    <title>{{ title }}</title>
</head>
<body>
<p >{{ menu|join:" | " }}</p>
<h1>{{ title }}</h1>
 
<ul>
    {% for p in posts %}
        <li>
            <h2>{{ p.title }}</h2>
            <p >{{ p.content }}</p>
            <hr>
        </li>
    {% endfor %}
</ul>
</body>
</html>
```
Внутри HTML-тега ul записан тег for шаблонизатора Django. Не путайте эти две вещи: есть теги разметки HTML-документа, а есть теги шаблонизатора. Теги шаблонизатора отрабатывают на стороне сервера и служат для формирования общего вида HTML-документа, который, затем, возвращается пользователю. А в браузере клиента обрабатываются уже HTML-теги, в частности, для форматирования выводимой информации на экране устройства. Так вот, тег for – это тег шаблонизатора Django, который работает по аналогии с оператором цикла for языка Python и в нашем примере перебирает переданную коллекцию posts. Конец тега-цикла for обязательно должно быть отмечено тегом endfor. Все, что попадает между этими тегами, образует тело цикла и повторяется на каждой итерации. То есть, на каждой итерации в HTML-документ будет добавляться тег li с соответствующим содержимым: заголовком h2, абзацем p с текстом статьи и разделительной линией (тег hr).

После запуска тестового веб-сервера и перехода на главную страницу увидим такую HTML-страницу:

![Пример вывода элементов после отработки цикла](images/cycle_ex.png)

Но у нас здесь, во-первых, выводится информация по Марго Робби, хотя для нее ключ is_published установлен в False и, во-вторых, последняя горизонтальная черта явно лишняя. Давайте поправим эти моменты. Вначале уберем последнюю горизонтальную черту. Для этого воспользуемся еще одним шаблонным тегом if, который позволяет проверять условия и работает подобно оператору if языка Python. Тег hr заключим в этот условный тег со следующей проверкой условия:
```html
<!-- index.html -->
...
<ul>
    {% for p in posts %}
        <li>
            <h2>{{p.title}}</h2>
            <p >{{p.content}}</p>
            {% if not forloop.last %}
                <hr>
            {% endif %}
        </li>
    {% endfor %}
</ul>
...
```
Внутри тега for можем использовать специальную переменную forloop, которая содержит некоторую [вспомогательную информацию](https://docs.djangoproject.com/en/4.2/ref/templates/builtins/#for).

В частности, переменную last, которая принимает значение True на последней итерации цикла. Поэтому условие not forloop.last истинно, пока мы не дошли до последней итерации. Соответственно, тег hr добавляется во все пункты li, кроме последнего. Обратите внимание, что в конце тега if обязательно нужно прописать тег endif. Все, что попадает в промежуток между if и endif образуют фрагмент HTML-документа, который включается или не включается в зависимости от истинности условия.

После обновления главной страницы увидим, что последняя горизонтальная черта пропала, как мы этого и хотели. Давайте теперь по аналогии будем отображать только те статьи, для которых значение поля is_published равно True. Сделать это можно следующим образом:
```html
<!-- index.html -->
<ul>
    {% for p in posts %}
        {% if p.is_published %}
            <li>
                <h2>{{p.title}}</h2>
                <p >{{p.content}}</p>
                {% if not forloop.last %}
                    <hr>
                {% endif %}
            </li>
        {% endif %}
    {% endfor %}
</ul>
```
Так как между шаблонными тегами if и endif заключен фрагмент с HTML-тегом li, то при ложном is_published соответствующая статья добавлена в HTML-документ не будет. И мы это увидим при обновлении главной страницы. На ней останется только две статьи.

Как видите, шаблонные теги for и if применять достаточно просто, и работают они аналогично операторам for и if языка Python. Например, в условиях также можно прописывать составные условия с применением операторов not, and и or. Добавлять блоки elif и else при необходимости. И, я думаю, с этим ни у кого из вас не возникнет никаких проблем, все достаточно очевидно.
### **12. Шаблонный тег url.**
Следующий важный шаг при разработке шаблонов – научиться правильно прописывать URL-адреса для ссылок. Я напомню, что ссылки в HTML-документе формируются с помощью тега <a> по следующему правилу:
```html
<a href="URL-адрес страницы">Название ссылки</a>
```
Например, мы можем в шаблоне index.html добавить ссылки для чтения поста следующим образом:
```html
<!-- index.html -->
...
<ul>
    {% for p in posts %}
        {% if p.is_published %}
            <li>
            <h2>{{p.title}}</h2>
            <p>{{p.content}}</p>
            <p><a href="post/{{p.id}}/">Читать пост</a></p>
            {% if not forloop.last %}
                <hr>
            {% endif %}
            </li>
        {% endif %}
    {% endfor %}
</ul>
...
```
Здесь p.id – это уникальный идентификатор статьи (мы его прописывали в коллекции data_db). При переходе на главную страницу под каждой статьей увидим ссылку:

![Пример ссылки на пост](images/post_link_ex.png)

Однако такой прямолинейный подход к описанию ссылок непосредственно в шаблоне – не лучший ход, сродни с хардкодингом. Например, если в будущем изменится шаблон URL-адреса для отображения статей, то изменения придется вносить во все шаблоны, где этот адрес прописан. А это, как вы понимаете, неэффективно и коряво. Было бы гораздо лучше динамически формировать URL-адреса, используя названия URL-шаблонов, которые мы прописывали в файле urls.py приложения women:
```python
# women/urls.py
urlpatterns = [
    path('', index, name='home'),
    path('about/', about, name='about'),
    path('cats/<int:cat_id>/', categories, name='cats_id'),
    path('cats/<slug:cat_slug>/', categories_by_slug, name='cats'),
    path('archive/<year4:year>/', archive, name='archive'),
]
```
Давайте здесь опишем три следующих маршрута:
```python
# women/urls.py
urlpatterns = [
    path('', index, name='home'),
    path('about/', about, name='about'),
    path('post/<int:post_id>/', show_post, name='post'),
]
```
Каждый маршрут имеет свое имя, которым мы в дальнейшем и будем пользоваться. Конечно, предполагается, что имена остаются неизменными на протяжении разработки всего проекта.

Добавим функцию представления show_post в модуль views.py приложения women, а другие не нужные функции удалим:
```python
# women/views.py
def show_post(request, post_id):
    return HttpResponse(f"Отображение статьи с id = {post_id}")
```
После этого перейдем в шаблон index.html и в нем сформируем URL-адреса для каждой статьи с помощью специального [шаблонного тега url](https://docs.djangoproject.com/en/4.2/ref/templates/builtins/):
```html
<!-- index.html -->
...
<p><a href="{% url 'post' p.id %}">Читать пост</a></p>
...
```
То есть, после тега url указывается имя маршрута ‘post’, а затем, через пробел аргумент p.id для формирования этого маршрута. Почему именно так? На самом деле тег url работает аналогично известной нам функции reverse. Если мы ее запишем в виде:
```python
reverse('post', args=(11, ))  # '/post/11/'
```
то получим маршрут '/post/11/'. И тот же эффект получаем от применения тега url:
```html
{% url 'post' 11 %}
```
Как видите, это гораздо более удобное решение для формирования URL-адресов. Если в будущем маршруты в файле urls.py изменятся, то изменения автоматически произойдут и в шаблоне. Ничего дополнительно редактировать не придется. В этом основное удобство использования шаблонного тега url.

Давайте в заключение добавим ссылки для главного меню сайта и отобразим его в HTML-документе. Вначале в файле urls.py мы пропишем следующие маршруты:
```python
# women/urls.py
urlpatterns = [
    path('', views.index, name='home'),
    path('about/', views.about, name='about'),
    path('addpage/', views.addpage, name='add_page'),
    path('contact/', views.contact, name='contact'),
    path('login/', views.login, name='login'),
    path('post/<int:post_id>/', views.show_post, name='post'),
]
```
А коллекцию menu изменим, добавив в нее информацию об именах маршрутов (в файле views.py). Также здесь сразу пропишем функции-заглушки для каждого пункта меню:
```python
# women/views.py
menu = [{'title': "О сайте", 'url_name': 'about'},
        {'title': "Добавить статью", 'url_name': 'add_page'},
        {'title': "Обратная связь", 'url_name': 'contact'},
        {'title': "Войти", 'url_name': 'login'}
]
...
def addpage(request):
    return HttpResponse("Добавление статьи")
 
def contact(request):
    return HttpResponse("Обратная связь")
 
def login(request):
    return HttpResponse("Авторизация")
```
Осталось в файле index.html выполнить отображение меню. Я сделаю это следующим образом:
```html
<!-- index.html -->
<ul>
    <li><a href="{% url 'home' %}">Главная</a></li>
    {% for m in menu %}
        {% if not forloop.last %}<li>{% else %}<li class="last">{% endif %}
        <a href="{% url m.url_name %}">{{m.title}}</a>
        </li>
    {% endfor %}
</ul>
```
После обновления главной страницы увидим список из ссылок пунктов главного меню сайта.
### **13. Наследование шаблонов (extends). Тег include.**
Отредактируем еще один about.html с выводом информации о сайте. В самом простом варианте его можно представить следующим образом:
```html
<!-- about.html -->
<!DOCTYPE html>
<html>
<head>
    <title>{{title}}</title>
</head>
<body>
 
<ul>
    <li><a href="{% url 'home' %}">Главная</a></li>
    {% for m in menu %}
    {% if not forloop.last %}<li>{% else %}<li class="last">{% endif %}
        <a href="{% url m.url_name %}">{{m.title}}</a>
    </li>
    {% endfor %}
</ul>
 
<h1>{{title}}</h1>
</body>
</html>
```
То есть, я просто скопировал начало шаблона из index.html и вставил в файл about.html.

Отредактируем функцию about в файле views.py, добавив передачу списка пунктов menu:
```python
# women/views.py
def about(request):
    return render(request, 'women/about.html', {'title': 'О сайте', 'menu': menu})
```
После запуска тестового веб-сервера и перехода по URL-адресу:
```http request
http://127.0.0.1:8000/about/
```
увидим страницу «О сайте» с выводом главного меню.

Однако, как вы уже догадались, дублирование информации в разных шаблонах нарушает известный принцип DRY – don’t repeat yourself (не повторяйся).

Для устранения этого недостатка, обычно создается базовый (общий) шаблон, содержащий общие элементы типовых страниц сайта, а уже потом он расширяется (дополняется деталями) шаблонами отдельных страниц. Такое расширение называется наследованием шаблонов. И сейчас мы на конкретном примере посмотрим, как это можно сделать.

Если перейти в документацию по фильтрам и тегам шаблонов фреймворка Django, то среди тегов можно встретить следующие:
```html
{% block <наименование> %} … {% endblock %}
{% extends <базовый шаблон> %}
```
Итак, вначале мы с вами определим базовый шаблон. Его, как правило, создают на уровне всего проекта. Поэтому создадим каталог templates в папке sitewomen, а в нем файл с именем base.html. Однако если мы сейчас попробуем обратиться к этому шаблону, например, в функции представления about:
```python
# women/views.py
def about(request):
    return render(request, 'base.html', {'title': 'О сайте', 'menu': menu})
```
то увидим ошибку, что шаблон не был найден. Это связано с тем, что маршрут templates/base.html не стандартный и его нужно явно прописать для шаблонизатора. Для этого нужно перейти в файл settings.py пакета конфигурации, найти параметр TEMPLATES и в коллекции DIRS прописать путь к каталогу templates следующим образом:
```python
# sitewomen/settings.py
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [
            BASE_DIR / 'templates',
        ],
        'APP_DIRS': True,
        ...
    },
]
```
Все, теперь при обновлении страницы «О сайте» мы увидим отображение базового шаблона.

Вернем прежний шаблон в функции about:
```python
# women/views.py
def about(request):
    return render(request, 'women/about.html', {'title': 'О сайте', 'menu': menu})
```
Давайте теперь общие элементы страниц сайта вынесем в базовый шаблон base.html. Для этого я скопирую все из файла about.html и посмотрим, что здесь у нас общее. Очевидно, все начало, включая отображение главного меню. А вот заголовок h1 и остальную часть страницы внутри тега body будем считать изменяемой. Поэтому вместо тега h1 мы пропишем специальный шаблонный тег block следующим образом:
```html
<!-- base.html. После копирования кода из about.html добавляем блок. -->
{% block content %} {% endblock %}
```
Здесь content – это название блока, вместо которого будет подставляться содержимое из наследуемых шаблонов.

Все, на этом базовый шаблон у нас с вами завершен. Осталось лишь расширить его для шаблонов index.html и about.html. Сначала перейдем в файл index.html и самой первой строчкой пропишем еще один шаблонный тег extends:
```html
<!-- index.html -->
{% extends 'base.html' %}
...
```
А ниже все уберем, кроме отображения заголовка 1-го уровня и списка статей. Эта информация должна быть размещена в блоке content базового шаблона. Поэтому здесь, в дочернем нам следует переопределить этот блок content следующим образом:
```html
<!-- index.html -->
{% block content %}
    <h1>{{title}}</h1>
    
    <ul>
        {% for p in posts %}
            {% if p.is_published %}
            <li>
                <h2>{{p.title}}</h2>
                <p >{{p.content}}</p>
                <p ><a href="{% url 'post' p.id %}">Читать пост</a></p>
                {% if not forloop.last %}
                    <hr>
                {% endif %}
            </li>
            {% endif %}
        {% endfor %}
    </ul>
{% endblock %}
```
То есть, мы просто заключили в этот тег то, что должно быть помещено в блок content базового шаблона.

Давайте посмотрим, как это будет работать. Перейдем на главную страницу сайта и видим полное содержимое HTML-документа, который мы с вами определили в базовом шаблоне base.html и в дочернем index.html.

По аналогии опишем расширение в шаблоне about.html:
```html
<!-- about.html -->
{% extends 'base.html' %}
 
{% block content %}
<h1>{{title}}</h1>
{% endblock %}
```
Переходим по ссылке на страницу «О сайте» и видим полноценную HTML-страницу с заголовком 1-го уровня. В результате мы с вами ушли от дублирования в отдельных шаблонах и можем достаточно просто определять страницы сайта, просто расширяя базовый шаблон base.html.
#### **Тег include.**
Помимо расширения шаблонов можно еще делать включение одного шаблона в другой. О чем здесь речь и для чего это нужно? Давайте представим, что мы бы хотели на главной странице нашего сайта (в шаблоне index.html) дополнительно отображать рубрики по известным женщинам в виде следующей навигационной панели из ссылок:
```html
<nav>
    <a href="#">Актрисы</a>
    <a href="#">Певицы</a> 
    <a href="#">Спортсменки</a>
</nav>
```
Причем делать это и сверху перед списком, и внизу после списка. В результате у нас получается дублирование фрагмента. Как раз чтобы этого избежать, применяется тег include, который позволяет добавлять в шаблон данные из другого шаблона. Давайте это сделаем.

Вначале мы создадим подкаталог includes в папке templates/women нашего проекта для лучшей организации структуры файлов шаблонов. Внутри каталога includes разместим файл nav.html и скопируем в него тег nav. А в шаблоне index.html подключим этот файл с помощью тега include следующим образом:
```html
<!-- index.html -->
{% extends 'base.html' %}
 
{% block content %}
    {% include 'women/includes/nav.html' %}
    
    <h1>{{title}}</h1>
    
    <ul>
        {% for p in posts %}
            {% if p.is_published %}
            <li>
                <h2>{{p.title}}</h2>
                <p >{{p.content}}</p>
                <p ><a href="{% url 'post' p.id %}">Читать пост</a></p>
                {% if not forloop.last %}
                    <hr>
                {% endif %}
            </li>
            {% endif %}
        {% endfor %}
    </ul>
    
    {% include 'women/includes/nav.html' %}
{% endblock %}
```
Причем сделали это в двух местах. При обновлении главной страницы увидим тот же результат, что и раньше, но при этом устранили дублирование фрагментов в шаблоне index.html.

Следует отметить, что при включении, шаблон nav.html имеет доступ ко всем параметрам, которые передаются в шаблон index.html. Например, в нем можно вывести заголовок:
```html
<!-- nav.html -->
<p>{{title}}</p>
```
Если же нам нужно запретить передачу переменных, то после пути к шаблону в теге include следует дополнительно прописать ключевое слово only:
```html
<!-- index.html -->
{% include 'women/includes/nav.html' only %}
```
А если нужно при этом передать отдельные параметры, то это можно сделать с помощью ключевого слова with следующим образом:
```html
<!-- index.html -->
{% include 'women/includes/nav.html' only with title='заголовок' %}
```
В итоге получаем довольно гибкий инструмент включения фрагментов в наши шаблоны.
